steps:
  # Etapa 1: Build da aplicação com Maven, garantindo um ambiente limpo.
  # Isso gera o arquivo JAR executável em target/
  - name: 'maven:3.9.6-eclipse-temurin-21'
    entrypoint: 'mvn'
    args:
      - 'clean'
      - 'package'
      - '-DskipTests'

  # Etapa 2: Build da imagem do contêiner com Docker
  # Isso usa o Dockerfile na raiz do projeto para construir a imagem
  # e a envia para o Artifact Registry.
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'build'
      - '-t'
      - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_REPOSITORY}/serveless-test-pubsub'
      - '.'

  # Etapa 3: Deploy no Cloud Run
  # Esta etapa usa a imagem enviada na etapa anterior para implantar o serviço.
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - 'serveless-test-pubsub-tutorial' # Nome do seu serviço no Cloud Run
      - '--image'
      - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_REPOSITORY}/serveless-test-pubsub'
      - '--region'
      - '${_REGION}'
      - '--allow-unauthenticated'
      - '--project'
      - '${_PROJECT_ID}'

# Define a imagem que será o resultado final deste build.
# O Cloud Build precisa saber qual imagem enviar para o Artifact Registry.
images:
  - '${_REGION}-docker.pkg.dev/${_PROJECT_ID}/${_REPOSITORY}/serveless-test-pubsub'

# Aponta para o bucket do Cloud Storage onde os logs de build serão armazenados.
logsBucket: 'gs://default-postech-fiap-build-logs'
